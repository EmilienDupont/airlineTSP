<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
<style>

@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
@import url(http://fonts.googleapis.com/css?family=Lato);
html {
   min-width: 1040px;
}

body {
   background: #fcfcfa;
   color: #333;
   font-family: "PT Serif", serif;
   /*margin: 0 1em 4em auto;*/
   position: relative;
   width: 960px;
   left: 13em;
}

h1, h2, h3, h4 { font-family: "Lato", "PT Serif", serif; color: #000; text-rendering: optimizeLegibility; }

h1 {
  font-size: 64px;
  line-height: 73px;
  font-weight: 900;
  margin-top: 0.67em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}

h2 {
   margin-top: 2em;
}

subtitle {
   display:block;
   font-family: "PT Serif", serif;
   font-size: 32px;
   font-style: italic;
   font-weight: 100;
}

p {
  line-height: 150%;
  width: 720px;
}

a {
  color: steelblue;
  cursor: auto;
}

a:not(:hover) {
   text-decoration: none;
}

pre {
   border-left: solid 2px #ccc;
   padding-left: 18px;
   margin: 2em 0 2em -20px;
}

aside {
   font-size: small;
   right: 0;
   position: absolute;
   width: 180px;
}

#nav {
        left: 5px;
        font-family: "Lato", serif;
        font-weight: 700;
        list-style: none;
        margin: 0;
        position: fixed;
        top: 10px;
        box-sizing: border-box;
}


#nav li {
        margin-bottom: 0px;
}

#nav a {
        color: #333;
        display: block;
        font-size: 14px;
        border-left: 3px solid #fcfcfa;
        padding: 5px 10px;
        text-decoration: none;
}

#nav a:hover {
   border-left: 3px solid steelblue;
}

#nav .current a {
   border-left: 3px solid steelblue;
}


.subunit-label {
  fill: #777;
  fill-opacity: .5;
  font-size: 20px;
  font-weight: 300;
  text-anchor: middle;
}

.place,
.place-label {
  fill: #444;
}

text {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 12px;
  pointer-events: none;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Flight Tour</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here
      <p> Shows the use of lazy constraints in Gurobi</p>
    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>We let the $n$ selected cities be the set of vertices $V$ of a graph. The set of edges
      $E$ of the graph corresponds to the different connections between each city. Since we can
      travel from any city to another, the graph is complete i.e. there is an edge between
      every pair of nodes. With each of these edges we associate a binary variable
      \[
      x_{ij} = \left\{\begin{array}{ll}
             1 & \text{if edge $(i,j) \in E$ is in tour }\\
             0 & \mathrm{otherwise}
            \end{array}\right.
      \]</p>

      <p> We want to minimize the total distance travelled through the tour. Therefore, we calculate
      the Euclidean distance between each pair of nodes. We denote this distance $d_{ij}$ for nodes
      $i$ and $j$. The total distance travelled is then the sum of the distances of the edges included
      in the tour, i.e.
      \[
      \text{length of tour} = \sum_{(i,j) \in E} d_{ij} x_{ij}
      \]
      </p>

      <p> Since we are computing a flight tour we should only pass through each city once. Therefore,
      for each node in the graph we should have exactly one incoming edge and one outgoing edge.
      In other words, for every node $i$ exactly two of $x_{ij}$ binary variables should be equal
      to 1. We write this as
      \[
      \sum_{j \in V} x_{ij} = 2 \quad \forall i \in V
      \]
      </p>

      <p> Solving the problem at this point would yield tours of the cities, but it may not yield
      a single tour. For example, figure ?? (add a figure here with 2 cycles) shows a solution to the problem as we have formulated is so
      far: each node has exactly two edges indcident on it. We therefore need to add an extra constraint.</p>

      <p> To eliminate the subtours we can add the following constraint. For each proper subset $S$ of the set of
      cities $V$, the number of edges between the nodes of $S$ must be at most $\left\vert{S}\right\vert - 1$.
      Indeed if the number of edges were equal to $S$ then we could form a subtour. For example, in figure
      ?? the subset of nodes $\{1,2,3\}$ has 3 edges. Therefore, for each proper subset $S$ of the nodes $V$ we
      add the constraint
      \[
      \sum_{i,j \in S, \, i \neq j} x_{ij} \leq  \left\vert{S}\right\vert - 1 \quad \forall S \subset V
      \]
      </p>

      <p> So finally the integer program formulation becomes
      \[
      \begin{array}{ll}
      \text{minimize} & \sum_{(i,j) \in E} d_{ij} x_{ij} \\
      \text{subject to} & \sum_{j \in V} x_{ij} = 2 \quad \forall i \in V \\
                        & \sum_{i,j \in S, \, i \neq j} x_{ij} \leq  \left\vert{S}\right\vert - 1 \quad \forall S \subset V  \\
                        & x_{ij} \in \{ 0, 1 \}
      \end{array}
      \]</p>

      <p> We note, however, that since there is an exponential number of subsets of the nodes $V$, there will
      be an exponential number of constraints of the type $\sum_{i,j \in S, \, i \neq j} x_{ij} \leq  \left\vert{S}\right\vert - 1$.
      We therefore add these as <em>lazy constraints</em>. Lazy constraints are inactive until a
      feasible solution is found. So for our example, Gurobi will first solve the MIP without the subtour constraints.
      If the computed tour has a length of $n$ then the problem is solved. Otherwise, if there is a
      subtour, we add in a constraint for the shortest subtour in the graph and solve the problem again. This
      process then continues until a tour of length $n$ has been found.</p>
    </div>
    
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
        import math
        import random
        from gurobipy import *


        # Callback - use lazy constraints to eliminate sub-tours

        def subtourelim(model, where):
            if where == GRB.callback.MIPSOL:
                selected = []
                # make a list of edges selected in the solution
                for i in range(n):
                    sol = model.cbGetSolution([model._vars[i,j] for j in range(n)])
                    selected += [(i,j) for j in range(n) if sol[j] > 0.5]
                # find the shortest cycle in the selected edge list
                tour = subtour(selected)
                if len(tour) < n:
                    # add a subtour elimination constraint
                    expr = 0
                    for i in range(len(tour)):
                        for j in range(i+1, len(tour)):
                            expr += model._vars[tour[i], tour[j]]
                    model.cbLazy(expr <= len(tour)-1)


        # Euclidean distance between two points

        def distance(points, i, j):
            dx = points[i][0] - points[j][0]
            dy = points[i][1] - points[j][1]
            return math.sqrt(dx*dx + dy*dy)


        # Given a list of edges, finds the shortest subtour

        def subtour(edges):
            visited = [False]*n
            cycles = []
            lengths = []
            selected = [[] for i in range(n)]
            for x,y in edges:
                selected[x].append(y)
            while True:
                current = visited.index(False)
                thiscycle = [current]
                while True:
                    visited[current] = True
                    neighbors = [x for x in selected[current] if not visited[x]]
                    if len(neighbors) == 0:
                        break
                    current = neighbors[0]
                    thiscycle.append(current)
                cycles.append(thiscycle)
                lengths.append(len(thiscycle))
                if sum(lengths) == n:
                    break
            return cycles[lengths.index(min(lengths))]

        n = 50

        # Create n random points

        random.seed(1)
        points = []
        for i in range(n):
            points.append((random.randint(0,100),random.randint(0,100)))

        m = Model()


        # Create variables

        vars = {}
        for i in range(n):
            for j in range(i+1):
                vars[i,j] = m.addVar(obj=distance(points, i, j), vtype=GRB.BINARY,
                                     name='e'+str(i)+'_'+str(j))
                vars[j,i] = vars[i,j]
        m.update()


        # Add degree-2 constraint, and forbid loops

        for i in range(n):
            m.addConstr(quicksum(vars[i,j] for j in range(n)) == 2)
            vars[i,i].ub = 0
        m.update()


        # Optimize model

        m._vars = vars
        m.params.LazyConstraints = 1
        m.optimize(subtourelim)

        solution = m.getAttr('x', vars)
        selected = [(i,j) for i in range(n) for j in range(n) if solution[i,j] > 0.5]
        assert len(subtour(selected)) == n

      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>
      Click on cities (or anywhere on the screen) to add them to the tour, and then press "Compute Tour".
      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute Tour</button>
    </div>

    <div style="min-height:100px"></div>
<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script>

var width = 960,
    height = 600;
    padding = 10;

var svg = d3.select("#demoarea").append("svg")
    .attr("width", width)
    .attr("height", height);

var voronoi = d3.geom.voronoi().clipExtent([[0, 0], [width, height]]);

// Need to put map in background

var mapG = svg.append("g");
var voronoiG = svg.append("g");
var labelG = svg.append("g");
var pointsG = svg.append("g");
var selectG = svg.append("g");

// Add the map
var projection = d3.geo.albers()
    .center([0, 39.7])
    .rotate([104.9, 0])
    .parallels([50, 60])
    .scale(1200)
    .translate([2*width / 5 , 0.5*height]);

var path = d3.geo.path()
    .projection(projection)
    .pointRadius(2);

// Create color gradient for the map
var mapColors = [];
var maxRed = 222, minRed = 49;
var maxGreen = 235, minGreen = 130;
var maxBlue = 247, minBlue = 189;
var numColors = 10;
for (var i = 0; i < numColors; i++) {
  var red = String( Math.round( minRed + (maxRed - minRed)*i/numColors ) );
  var green = String( Math.round( minGreen + (maxGreen - minGreen)*i/numColors) );
  var blue = String( Math.round( minBlue + (maxBlue - minBlue)*i/numColors ) );
  mapColors.push( "rgb(" + red + "," + green + "," + blue + ")");
}

// Data structures needed for airport data
var airports = [];
var airportInfo = [];
var airportIds = [];
var airportNum = 0;
var voroPath;

d3.json("USwithCities5.json", function(error, us) {
  var states = topojson.feature(us, us.objects.statesUSA);
  var places = topojson.feature(us, us.objects.placesUSA5);

  mapG.selectAll(".subunit")
      .data(states.features)
      .enter().append("path")
      .attr("fill", function(d,i) { return mapColors[i % 9];})
      .attr("stroke", "white")
      .attr("stroke-width", 1)
      .attr("opacity", .8)
      .attr("d", path);

  mapG.selectAll(".subunit-label")
      .data(states.features)
      .enter().append("text")
      .attr("class", function(d) { return "subunit-label " + d.id; })
      .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
      .attr("dy", ".35em")
      .text(function(d) { return d.properties.name; });

  mapG.append("path")
      .datum(places)
      .attr("d", path)
      .attr("class", "place");

  for (var i = 0; i < places.features.length; i++) {
    airports.push(projection(places.features[i].geometry.coordinates));
    airportInfo.push(places.features[i].properties.name);
  }

  console.log('airports', airports);

  // Have to do this filter because some of the airports are also in Canada, Mexico etc...
  // Since they will become zero and cause problems
  var dataAirports = voronoi(airports).filter(nonzeroArray);
  console.log(dataAirports);
  console.log(airportIds);

  labelG.selectAll(".place-label")
      .data(places.features)
      .enter().append("text")
      .attr("class", "place-label")
      .attr("transform", function(d) { return "translate(" + projection(d.geometry.coordinates) + ")"; })
      .attr("x", function(d) { return projection(d.geometry.coordinates[0]) > -1 ? 6 : -6; })
      .attr("dy", ".35em")
      .style("text-anchor", function(d) { return projection(d.geometry.coordinates[0]) > -1 ? "start" : "end"; })
      .text(function(d) { return d.properties.name; })
      .attr("id", function(d,i) { if (airportIds[i] > -1) { return "p" + airportIds[i]; } else {return "n" + i;} })
      .attr("opacity", 0);

  var voroPath = voronoiG.selectAll("polygon")
                        .data(dataAirports)
                        .enter()
                        .append("polygon")
                        .attr("points", function(d) { return d; })
                        .attr("fill", "black")
                        .attr("opacity", 0)
                        .attr("id", function(d,i) { return i;})
                        .attr("stroke", "black")
                        .attr("stroke-width", 2)
                        .attr("stroke-opacity", 1)
                        .on("mouseover", mouseover)
                        .on("mouseout", mouseout)
                        .on("mousedown", mousedown);
});

function nonzeroArray(value) {
  if (value.length > 0) {
    airportIds.push(airportNum);
    airportNum++;
  } else {
    airportIds.push(-1);
  }
  return value.length > 0;
}

function polygon(d) {
  return "M" + d.join("L") + "Z";
}

function mouseover() {
  d3.select(this).attr("opacity", .1);
  var id = d3.select(this).attr("id");
  var place = "#p" + id;
  d3.select(place).attr("opacity", 1);
}

function mouseout() {
  d3.select(this).attr("opacity", 0);
  var id = d3.select(this).attr("id");
  var place = "#p" + id;
  d3.select(place).attr("opacity", 0);
}

// Create some data (vertices of the graph here)
// New York, Houston, SF, Seattle, Minneapolis, Denver coordinates
var nodes = [[868.9435806134477, 169.89036899270104], [568.4792351442809, 485.81616835323234],
             [88.00091068848855, 302.2404899932818], [138.92361765862051, 106.63257539875156],
             [557.4835260884684, 176.6910465103682], [382.642835580352, 299.1252133874681]];
var names = ["New York", "Houston", "San Francisco", "Seattle", "Minneapolis", "Denver"];

var circles = pointsG.selectAll("circle") // Select all the circles (that do not yet exist...)
                 .data(nodes) // Iterate over the dataset
                 .enter() // create an object
                 .append("circle"); // actually add circles

  circles.attr("cx", function(d, i) { // cx is x coordinate of center // d always refers to the dataset linked to the circle // i is an index referring to each circle in dataset
            return nodes[i][0]; // i.e move x coordinate of center to the right
            })
            .attr("cy", function(d, i) { // cx is x coordinate of center // d always refers to the dataset linked to the circle // i is an index referring to each circle in dataset
            return nodes[i][1]; // i.e move x coordinate of center to the right
            })
            .attr("r", 4)
            .attr("fill",  "rgb(0, 0, 150)")
            .attr("stroke", "rgb(0, 0, 150)")
            .attr("stroke-opacity", 0.5)
            .attr("stroke-width", 3);

for (var i = 0; i < names.length; i++) {
  selectG.append("text")
         .attr("transform", function(d) { return "translate(" + nodes[i] + ")"; })
         .attr("x", function(d) { return nodes[i][0] > -1 ? 6 : -6; })
         .attr("dy", ".35em")
         .style("text-anchor", function(d) { return nodes[i][0] > -1 ? "start" : "end"; })
         .text(names[i])
         .attr("id", String(names[i]).replace(/ /g, ''))
         .attr("fill", "blue");
}

function indexArray (array, point) {
  var p0 = point[0];
  var p1 = point[1];
  var index = -1;
  for (i = 0; i < array.length; i++) {
    pointprime = array[i];
    if (p0 === pointprime[0] && p1 === pointprime[1]) {
      index = i;
      break;
    }
  }
  return index;
}

function mousedown() {
  var id = d3.select(this).attr("id");
  id = parseInt(id);
  console.log('id', id);
  var num = airportIds.indexOf(id);
  console.log('num',num);
  var point = airports[num];
  console.log(point);

  if (indexArray(nodes, point) > -1) {
    console.log('point already exists!');
    nodes.splice(indexArray(nodes, point),1);
    // Remove label
    var labelId = "#" + String(airportInfo[num]).replace(/ /g, ''); // remove whitespace from id
    console.log(labelId);
    selectG.select(labelId).remove("text");
  } else {
    nodes.push(point);
    // Add label
    selectG.append("text")
         .attr("transform", function(d) { return "translate(" + airports[num] + ")"; })
         .attr("x", function(d) { return airports[num][0] > -1 ? 6 : -6; })
         .attr("dy", ".35em")
         .style("text-anchor", function(d) { return airports[num][0] > -1 ? "start" : "end"; })
         .text(airportInfo[num])
         .attr("id", String(airportInfo[num]).replace(/ /g, ''))
         .attr("fill", "blue");
  }

  // Draw the nodes
  pointsG.selectAll("circle").remove("circle");

  var circles = pointsG.selectAll("circle") // Select all the circles (that do not yet exist...)
                 .data(nodes) // Iterate over the dataset
                 .enter() // create an object
                 .append("circle"); // actually add circles

  circles.attr("cx", function(d, i) { // cx is x coordinate of center // d always refers to the dataset linked to the circle // i is an index referring to each circle in dataset
            return nodes[i][0]; // i.e move x coordinate of center to the right
            })
            .attr("cy", function(d, i) { // cx is x coordinate of center // d always refers to the dataset linked to the circle // i is an index referring to each circle in dataset
            return nodes[i][1]; // i.e move x coordinate of center to the right
            })
            .attr("r", 4)
            .attr("fill",  "rgb(0, 0, 150)")
            .attr("stroke", "rgb(0, 0, 150)")
            .attr("stroke-opacity", 0.5)
            .attr("stroke-width", 3);
}

function compute() {
  var vertices = nodes;
  for (var i = 0; i < nodes.length; i++) {
     console.log("x", nodes[i][0])
     console.log("y", nodes[i][1])
  }
  console.log('vertices', vertices);

  d3.json('/airlineTSP')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'vertices': vertices}), serverResponse);
}


function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);
   if (!error) {
      if ('tour' in data) {
        var tour = data.tour;
        console.log('tour', tour);

        // Get list of edges of tour
        var src = tour[0];
        links = [];
        for (var i = 1; i < tour.length; i++) {
          links.push([src, tour[i]]);
          src = tour[i];
        }
        links.push([tour[tour.length-1], tour[0]]);

        console.log('links', links);

        // Draw lines between points
        var lines = svg.selectAll("line")
                        .remove()

        var lines = svg.selectAll("line")
                        .data(links)
                        .enter()
                        .append("line");

        lines.style("stroke", "orange")
             .style("opacity", 0.5)
             .style("stroke-width", 2)
              .attr("x1", function(d,i) {
                var node1 = nodes[links[i][0]];
                var x1 = node1[0]
                return x1;
              })
              .attr("y1", function(d,i) {
                var node1 = nodes[links[i][0]];
                var y1 = node1[1]
                return y1;
              })
              .attr("x2", function(d,i) {
                var node2 = nodes[links[i][1]];
                var x2 = node2[0]
                return x2;
              })
              .attr("y2", function(d,i) {
                var node2 = nodes[links[i][1]];
                var y2 = node2[1]
                return y2;
              })
      }
   }
}

</script>
